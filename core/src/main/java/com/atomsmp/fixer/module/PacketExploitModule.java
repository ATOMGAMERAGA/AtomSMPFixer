package com.atomsmp.fixer.module;

import com.atomsmp.fixer.AtomSMPFixer;
import com.atomsmp.fixer.data.PlayerData;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.protocol.packettype.PacketTypeCommon;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Paket Exploit Modülü
 *
 * Paket boyutu ve rate kontrolü yaparak exploit'leri önler.
 * Tüm gelen paketleri kontrol eder ve şüpheli aktiviteleri engeller.
 *
 * Özellikler:
 * - Maksimum paket boyutu kontrolü
 * - Maksimum paket oranı kontrolü (Global ve Tür Bazlı)
 * - Tüm gelen paket türlerinin kontrolü
 * - Oyuncu bazlı paket tracking
 *
 * @author AtomSMP
 * @version 4.0.0
 */
public class PacketExploitModule extends AbstractModule {

    private PacketListenerAbstract listener;

    // Oyuncu verilerini saklayan map
    private final Map<UUID, PlayerData> playerDataMap;
    private final Map<UUID, Long> lastPacketTime;
    private final Map<UUID, Integer> packetCounts;

    // CR-08: Tür bazlı limitler
    private final Map<PacketTypeCommon, Integer> typeLimits = new HashMap<>();
    private final Map<UUID, Map<PacketTypeCommon, Integer>> typeCounts = new ConcurrentHashMap<>();

    // Config cache
    private int maxPacketSize;
    private int maxPacketRate;
    private long timeWindowMs;

    /**
     * PacketExploitModule constructor
     *
     * @param plugin Ana plugin instance
     */
    public PacketExploitModule(@NotNull AtomSMPFixer plugin) {
        super(plugin, "paket-exploit", "Paket boyutu ve rate kontrolü");
        this.playerDataMap = new ConcurrentHashMap<>();
        this.lastPacketTime = new ConcurrentHashMap<>();
        this.packetCounts = new ConcurrentHashMap<>();
    }

    @Override

    public void onEnable() {
        super.onEnable();

        // Config değerlerini yükle
        loadConfig();

        // PacketEvents listener'ı oluştur ve kaydet
        listener = new PacketListenerAbstract(PacketListenerPriority.NORMAL) {
            @Override
            public void onPacketReceive(PacketReceiveEvent event) {
                handlePacketReceive(event);
            }
        };

        com.github.retrooper.packetevents.PacketEvents.getAPI()
            .getEventManager()
            .registerListener(listener);

        debug("Modül aktifleştirildi. Max boyut: " + maxPacketSize +
              " bytes, Max rate: " + maxPacketRate + "/s");
    }

    @Override

    public void onDisable() {
        super.onDisable();

        // PacketEvents listener'ı kaldır
        if (listener != null) {
            com.github.retrooper.packetevents.PacketEvents.getAPI()
                .getEventManager()
                .unregisterListener(listener);
        }

        // Map'leri temizle
        playerDataMap.clear();
        lastPacketTime.clear();
        packetCounts.clear();
        typeCounts.clear();

        debug("Modül devre dışı bırakıldı.");
    }

    /**
     * Config değerlerini yükler
     */
    private void loadConfig() {
        this.maxPacketSize = getConfigInt("max-paket-boyutu", 2097152); // 2MB
        this.maxPacketRate = getConfigInt("max-paket-orani", 800);
        this.timeWindowMs = getConfigLong("zaman-penceresi-ms", 1000L);

        // CR-08: Type based limits
        typeLimits.clear();
        typeLimits.put(PacketType.Play.Client.PLUGIN_MESSAGE, getConfigInt("tur-bazli-limitler.PLUGIN_MESSAGE", 50));
        typeLimits.put(PacketType.Play.Client.CLICK_WINDOW, getConfigInt("tur-bazli-limitler.CLICK_WINDOW", 100));
        typeLimits.put(PacketType.Play.Client.CREATIVE_INVENTORY_ACTION, getConfigInt("tur-bazli-limitler.CREATIVE_INVENTORY_ACTION", 50));
        typeLimits.put(PacketType.Play.Client.EDIT_BOOK, getConfigInt("tur-bazli-limitler.EDIT_BOOK", 5));
        typeLimits.put(PacketType.Play.Client.UPDATE_SIGN, getConfigInt("tur-bazli-limitler.UPDATE_SIGN", 10));
        typeLimits.put(PacketType.Play.Client.CHAT_MESSAGE, getConfigInt("tur-bazli-limitler.CHAT_MESSAGE", 20));

        debug("Config yüklendi: maxSize=" + maxPacketSize +
              ", maxRate=" + maxPacketRate +
              ", timeWindow=" + timeWindowMs + "ms");
    }

    /**
     * Paket alındığında çağrılır
     */
    private void handlePacketReceive(PacketReceiveEvent event) {
        if (!isEnabled()) {
            return;
        }

        // Login/Handshake aşamasında player henüz Bukkit Player değil, ClassCastException önleme
        if (!(event.getPlayer() instanceof Player player)) {
            return;
        }

        UUID uuid = player.getUniqueId();

        // PlayerData al veya oluştur
        PlayerData playerData = getOrCreatePlayerData(uuid, player.getName());

        // Paket sayısını artır
        playerData.incrementReceivedPackets();

        // Rate kontrolü (Global ve Tür Bazlı)
        if (isRateLimitExceeded(uuid, event.getPacketType())) {
            incrementBlockedCount();
            playerData.incrementBlockedPackets();

            logExploit(player.getName(),
                String.format("Paket rate limiti aşıldı! Type: %s", event.getPacketType().getName()));

            event.setCancelled(true);
            debug(player.getName() + " için paket engellendi (rate limit)");
            return;
        }
    }

    /**
     * Rate limit kontrolü yapar
     */
    private boolean isRateLimitExceeded(@NotNull UUID uuid, PacketTypeCommon type) {
        long currentTime = System.currentTimeMillis();
        long lastTime = lastPacketTime.getOrDefault(uuid, 0L);

        // Zaman penceresi dışındaysa sayacı sıfırla
        if (currentTime - lastTime > timeWindowMs) {
            packetCounts.put(uuid, 0);
            typeCounts.remove(uuid);
            lastPacketTime.put(uuid, currentTime);
        }

        // Global limit kontrolü
        int globalCount = packetCounts.merge(uuid, 1, Integer::sum);
        if (globalCount > maxPacketRate) {
            return true;
        }

        // Tür bazlı limit kontrolü (CR-08)
        if (typeLimits.containsKey(type)) {
            Map<PacketTypeCommon, Integer> userTypeCounts = typeCounts.computeIfAbsent(uuid, k -> new HashMap<>());
            int typeCount = userTypeCounts.merge(type, 1, Integer::sum);
            if (typeCount > typeLimits.get(type)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Mevcut paket rate'ini döndürür
     */
    private int getCurrentRate(@NotNull UUID uuid) {
        long currentTime = System.currentTimeMillis();
        long lastTime = lastPacketTime.getOrDefault(uuid, 0L);

        if (currentTime - lastTime > timeWindowMs) {
            return 0;
        }

        return packetCounts.getOrDefault(uuid, 0);
    }

    /**
     * PlayerData alır veya oluşturur
     */
    @NotNull
    private PlayerData getOrCreatePlayerData(@NotNull UUID uuid, @NotNull String name) {
        return playerDataMap.computeIfAbsent(uuid, k -> new PlayerData(uuid, name));
    }

    /**
     * Oyuncu verisini kaldırır
     */
    public void removePlayerData(@NotNull UUID uuid) {
        playerDataMap.remove(uuid);
        lastPacketTime.remove(uuid);
        packetCounts.remove(uuid);
        typeCounts.remove(uuid);
    }

    /**
     * Tüm oyuncu verilerini temizler
     */
    public void clearAllPlayerData() {
        playerDataMap.clear();
        lastPacketTime.clear();
        packetCounts.clear();
        typeCounts.clear();
    }

    /**
     * Modül istatistiklerini döndürür
     */
    public String getStatistics() {
        long totalPackets = playerDataMap.values().stream()
            .mapToLong(PlayerData::getTotalPacketsReceived)
            .sum();

        int totalBlocked = playerDataMap.values().stream()
            .mapToInt(PlayerData::getBlockedPackets)
            .sum();

        return String.format("Takip edilen oyuncu: %d, Toplam paket: %d, Engellenen: %d",
            playerDataMap.size(),
            totalPackets,
            totalBlocked);
    }

    /**
     * Belirli bir oyuncunun istatistiklerini döndürür
     */
    public String getPlayerStatistics(@NotNull UUID uuid) {
        PlayerData data = playerDataMap.get(uuid);
        if (data == null) {
            return "Oyuncu verisi bulunamadı";
        }

        return String.format("Alınan paket: %d, Engellenen: %d, Mevcut rate: %d/s",
            data.getTotalPacketsReceived(),
            data.getBlockedPackets(),
            getCurrentRate(uuid));
    }

    /**
     * Memory optimization - kullanılmayan verileri temizler
     */
    public void cleanup() {
        long currentTime = System.currentTimeMillis();
        long expiryTime = 300000; // 5 dakika

        lastPacketTime.entrySet().removeIf(entry ->
            currentTime - entry.getValue() > expiryTime);

        packetCounts.entrySet().removeIf(entry ->
            !lastPacketTime.containsKey(entry.getKey()));
        
        typeCounts.entrySet().removeIf(entry ->
            !lastPacketTime.containsKey(entry.getKey()));
    }
}