package com.atomsmp.fixer.module;

import com.atomsmp.fixer.AtomSMPFixer;
import com.atomsmp.fixer.data.PlayerData;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import org.bukkit.entity.Player;
import org.jetbrains.annotations.NotNull;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Paket Exploit Modülü
 *
 * Paket boyutu ve rate kontrolü yaparak exploit'leri önler.
 * Tüm gelen paketleri kontrol eder ve şüpheli aktiviteleri engeller.
 *
 * Özellikler:
 * - Maksimum paket boyutu kontrolü
 * - Maksimum paket oranı kontrolü
 * - Tüm gelen paket türlerinin kontrolü
 * - Oyuncu bazlı paket tracking
 *
 * @author AtomSMP
 * @version 1.0.0
 */
public class PacketExploitModule extends AbstractModule {

    private PacketListenerAbstract listener;

    // Oyuncu verilerini saklayan map
    private final Map<UUID, PlayerData> playerDataMap;
    private final Map<UUID, Long> lastPacketTime;
    private final Map<UUID, Integer> packetCounts;

    // Config cache
    private int maxPacketSize;
    private int maxPacketRate;
    private long timeWindowMs;

    /**
     * PacketExploitModule constructor
     *
     * @param plugin Ana plugin instance
     */
    public PacketExploitModule(@NotNull AtomSMPFixer plugin) {
        super(plugin, "paket-exploit", "Paket boyutu ve rate kontrolü");
        this.playerDataMap = new ConcurrentHashMap<>();
        this.lastPacketTime = new ConcurrentHashMap<>();
        this.packetCounts = new ConcurrentHashMap<>();
    }

    @Override
    public void onEnable() {
        super.onEnable();

        // Config değerlerini yükle
        loadConfig();

        // PacketEvents listener'ı oluştur ve kaydet
        listener = new PacketListenerAbstract(PacketListenerPriority.NORMAL) {
            @Override
            public void onPacketReceive(PacketReceiveEvent event) {
                handlePacketReceive(event);
            }
        };

        com.github.retrooper.packetevents.PacketEvents.getAPI()
            .getEventManager()
            .registerListener(listener);

        debug("Modül aktifleştirildi. Max boyut: " + maxPacketSize +
              " bytes, Max rate: " + maxPacketRate + "/s");
    }

    @Override
    public void onDisable() {
        super.onDisable();

        // PacketEvents listener'ı kaldır
        if (listener != null) {
            com.github.retrooper.packetevents.PacketEvents.getAPI()
                .getEventManager()
                .unregisterListener(listener);
        }

        // Map'leri temizle
        playerDataMap.clear();
        lastPacketTime.clear();
        packetCounts.clear();

        debug("Modül devre dışı bırakıldı.");
    }

    /**
     * Config değerlerini yükler
     */
    private void loadConfig() {
        this.maxPacketSize = getConfigInt("max-paket-boyutu", 2097152); // 2MB
        this.maxPacketRate = getConfigInt("max-paket-orani", 200);
        this.timeWindowMs = getConfigLong("zaman-penceresi-ms", 1000L);

        debug("Config yüklendi: maxSize=" + maxPacketSize +
              ", maxRate=" + maxPacketRate +
              ", timeWindow=" + timeWindowMs + "ms");
    }

    /**
     * Paket alındığında çağrılır
     */
    private void handlePacketReceive(PacketReceiveEvent event) {
        if (!isEnabled()) {
            return;
        }

        Player player = (Player) event.getPlayer();
        if (player == null) {
            return;
        }

        UUID uuid = player.getUniqueId();

        // PlayerData al veya oluştur
        PlayerData playerData = getOrCreatePlayerData(uuid, player.getName());

        // Paket sayısını artır
        playerData.incrementReceivedPackets();

        // Rate kontrolü
        if (isRateLimitExceeded(uuid)) {
            incrementBlockedCount();
            playerData.incrementBlockedPackets();

            logExploit(player.getName(),
                String.format("Paket rate limiti aşıldı! Rate: %d/s (Limit: %d/s)",
                    getCurrentRate(uuid),
                    maxPacketRate));

            event.setCancelled(true);
            debug(player.getName() + " için paket engellendi (rate limit)");
            return;
        }

        // Paket boyutu kontrolü (yaklaşık)
        // Not: PacketEvents doğrudan boyut bilgisi vermediği için bu kontrol teorik
        String packetType = event.getPacketType().getName();
        if (isSuspiciousPacketType(packetType)) {
            debug(player.getName() + " şüpheli paket gönderdi: " + packetType);
        }

        // Paket sayacını güncelle
        updatePacketCount(uuid);
    }

    /**
     * Rate limit kontrolü yapar
     */
    private boolean isRateLimitExceeded(@NotNull UUID uuid) {
        long currentTime = System.currentTimeMillis();
        long lastTime = lastPacketTime.getOrDefault(uuid, 0L);

        // Zaman penceresi dışındaysa sayacı sıfırla
        if (currentTime - lastTime > timeWindowMs) {
            packetCounts.put(uuid, 0);
            lastPacketTime.put(uuid, currentTime);
        }

        int count = packetCounts.getOrDefault(uuid, 0);
        return count >= maxPacketRate;
    }

    /**
     * Paket sayacını günceller
     */
    private void updatePacketCount(@NotNull UUID uuid) {
        packetCounts.merge(uuid, 1, Integer::sum);
        lastPacketTime.put(uuid, System.currentTimeMillis());
    }

    /**
     * Mevcut paket rate'ini döndürür
     */
    private int getCurrentRate(@NotNull UUID uuid) {
        long currentTime = System.currentTimeMillis();
        long lastTime = lastPacketTime.getOrDefault(uuid, 0L);

        if (currentTime - lastTime > timeWindowMs) {
            return 0;
        }

        return packetCounts.getOrDefault(uuid, 0);
    }

    /**
     * Şüpheli paket türü kontrolü
     */
    private boolean isSuspiciousPacketType(@NotNull String packetType) {
        // Bazı paket türleri exploit için kullanılabilir
        return packetType.contains("CustomPayload") ||
               packetType.contains("TabComplete") ||
               packetType.contains("UpdateSign");
    }

    /**
     * PlayerData alır veya oluşturur
     */
    @NotNull
    private PlayerData getOrCreatePlayerData(@NotNull UUID uuid, @NotNull String name) {
        return playerDataMap.computeIfAbsent(uuid, k -> new PlayerData(uuid, name));
    }

    /**
     * Oyuncu verisini kaldırır
     */
    public void removePlayerData(@NotNull UUID uuid) {
        playerDataMap.remove(uuid);
        lastPacketTime.remove(uuid);
        packetCounts.remove(uuid);
    }

    /**
     * Tüm oyuncu verilerini temizler
     */
    public void clearAllPlayerData() {
        playerDataMap.clear();
        lastPacketTime.clear();
        packetCounts.clear();
    }

    /**
     * Modül istatistiklerini döndürür
     */
    public String getStatistics() {
        long totalPackets = playerDataMap.values().stream()
            .mapToLong(PlayerData::getTotalPacketsReceived)
            .sum();

        int totalBlocked = playerDataMap.values().stream()
            .mapToInt(PlayerData::getBlockedPackets)
            .sum();

        return String.format("Takip edilen oyuncu: %d, Toplam paket: %d, Engellenen: %d",
            playerDataMap.size(),
            totalPackets,
            totalBlocked);
    }

    /**
     * Belirli bir oyuncunun istatistiklerini döndürür
     */
    public String getPlayerStatistics(@NotNull UUID uuid) {
        PlayerData data = playerDataMap.get(uuid);
        if (data == null) {
            return "Oyuncu verisi bulunamadı";
        }

        return String.format("Alınan paket: %d, Engellenen: %d, Mevcut rate: %d/s",
            data.getTotalPacketsReceived(),
            data.getBlockedPackets(),
            getCurrentRate(uuid));
    }

    /**
     * Memory optimization - kullanılmayan verileri temizler
     */
    public void cleanup() {
        long currentTime = System.currentTimeMillis();
        long expiryTime = 300000; // 5 dakika

        lastPacketTime.entrySet().removeIf(entry ->
            currentTime - entry.getValue() > expiryTime);

        packetCounts.entrySet().removeIf(entry ->
            !lastPacketTime.containsKey(entry.getKey()));
    }
}
